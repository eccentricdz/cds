---
description: USE THIS whenever you are asked to work on CDS React components
alwaysApply: false
---

# React Component Development Rules

## Component Development Workflow

1. Research similar reference components and given requirements/description
2. Optionally, ask clarifying questions about the component's requirements & behavior
3. Implement the component with unit tests & stories on web first before proceeding to mobile if both platforms were requested.
4. Never write figma code connect files unless explicitly instructed to do so.
5. Follow remaining general coding standards and guidelines you've been given.

## Reference Components

These high quality components demonstrate proper use of patterns/conventions:

- **Select** (alpha/): generics, controlled/uncontrolled, compound architecture
- **Stepper**: props-based defaults, metadata generics, compound components
- **Carousel** (web): compound components, imperative handle, context + hook
- **RollingNumber**: animation config extraction, measurement patterns
- **SlideButton** (mobile): gesture handling, spring animations, accessibility actions

## Organization

- Every main CDS component should live within it own folder.
- Component folders main contain other React component that used exclusively by the main component.
  **Sample structure:**
  ```
  ComponentName/
  ├── ComponentName.tsx       # Main component file
  ├── SubComponent.tsx        # Supporting component
  ├── index.ts                # Re-exports for public API
  ├── __stories__/            # Storybook stories
  ├── __tests__/              # Unit tests
  ├── __figma__/              # Figma exports (Code Connect bindings)
  ```

## Component Conventions

- **Memoize**: Always memoize components with React's memo HOC
- **refs**: All components should accept a ref via React's forwardRef pattern
- **Props documentation**: Every prop must have JSDoc comments with `@default` tags where applicable
- **Type exports**: Export both a `*BaseProps` and `*Props` type (e.g., `ButtonBaseProps`, `ButtonProps`)
- **Style overrides**: All components MUST support a way to override styles (varries by web/mobile platform)
- **testID**: Support `testID` prop on root element for every component
- **Use design tokens**: Reference packages/common/src/core/theme.ts:57-331 as the definitive source for available token names
- **Padding over margin**: Use padding in combination with flex gap to achieve spacing instead of margin.

## Component Patterns

### Compound Components

- Break components down into discrete subcomponents (i.e. "slots")
- Use this pattern for complex components with clear, distinct parts
- Accept optional subcomponent props with sensible defaults using `*Component`/`Default*` naming:
  ```ts
  NavigationComponent = DefaultCarouselNavigation,
  PaginationComponent = DefaultCarouselPagination,
  ```
- The names of classNames/styles keys must line up with the name of the subcomponents (e.g. `classNames.pagination`, `styles.pagination`).
- Examples: Stepper, Carousel, Select (alpha)

**Benefits:**

- Complete customization without forking
- Sensible defaults for common use case
- Exported subcomponents for consumers to customize/wrap themselves

### Context + Hook Pattern

- Pair contexts with `use*Context()` hooks that throw descriptive errors on misuse:
  ```ts
  export const useCarouselContext = () => {
    const context = useContext(CarouselContext);
    if (!context) throw new Error('useCarouselContext must be used within Carousel');
    return context;
  };
  ```

### Controlled/Uncontrolled Components

- Support both patterns for input components; validate and throw if consumer mixes them (e.g., provides `value` but not `onChange`)
- Use internal state with prop override: `const open = openProp ?? openInternal;`

### Generics for Type Safety

- Use generics for components with dynamic value types:
  ```ts
  type SelectComponent = <Type extends SelectType, Value extends string>(
    props: SelectProps<Type, Value>,
  ) => React.ReactElement;
  ```
- Examples: Select (alpha), Stepper

### BaseProps & Props

- Component modules encapsulate two prop Types: `*BaseProps` (platform-agnostic) and `*Props` (extends BaseProps with platform and component specific properties like `className`, `classNames`, `styles`, etc.)
- Reuse other components' Types via utilities: `Pick` being preferred then secondarily `Omit`/`Exclude`
- Compose prop types using Typescript intersections (`&`) in this order: (1) full types (2) Picks (3) Omits (4) other type literal(s):
  ```ts
  type MyComponentProps = BoxBaseProps &
    Pick<OtherComponentProps, 'someProp'> &
    Omit<AnotherComponentProps, 'otherProp'> & {
      propA: string;
      propB: number;
    };
  ```
